# Aufgaben 1
# Aufgabe 1: Prozesse

## Wasserfallmodell-Diagramm:
Hier würde ich die Begriffe in der folgenden Reihenfolge von oben nach unten anordnen:
- Anforderungsdefinition
- Systementwurf
- Implementierung
- Integration
- Betrieb und Wartung

Diese Reihenfolge entspricht dem typischen Ablauf des Wasserfallmodells in der Softwareentwicklung.

## Wahr oder Falsch-Frage:
Die Aussage "Zu den Vorteilen des iterativen Prozessmodells zählt die einfachere Projektplanung" ist falsch.

**Begründung:** Iterative Modelle sind in der Regel komplexer in der Planung, da sie mehrere Durchläufe und Anpassungen vorsehen. Die einfachere Projektplanung ist eher ein Vorteil des Wasserfallmodells.

# Aufgabe 2: Architektur
Für eine native Windows-Anwendung zur Zeiterfassung würde ich folgende zwei UML-Diagramme vorschlagen:

## Anwendungsfalldiagramm (Use Case Diagram):
**Beschreibung:** Zeigt die Interaktionen zwischen Benutzern und dem System.  
**Einsatz:** Hilft bei der Identifizierung der Hauptfunktionen wie "Zeit erfassen", "Bericht generieren" etc.

## Klassendiagramm:
**Beschreibung:** Stellt die Struktur des Systems dar, einschließlich Klassen, Attribute und Beziehungen.  
**Einsatz:** Hilft bei der Modellierung der Datenstruktur für Zeiteinträge, Benutzer und System-Tray-Interaktionen.

# Aufgabe 3: Verschiedenes

## Iterative Entwicklung:
**Definition:** Wiederholtes Durchlaufen von Entwicklungsphasen, um das Produkt schrittweise zu verbessern.  
**Beispiel:** Ein Textverarbeitungsprogramm wird zunächst mit grundlegenden Funktionen entwickelt. In jeder Iteration werden Funktionen verfeinert und neue hinzugefügt.

## Inkrementelle Entwicklung:
**Definition:** Schrittweise Entwicklung und Auslieferung von Teilfunktionalitäten des Gesamtsystems.  
**Beispiel:** Ein E-Commerce-System wird in Inkrementen entwickelt - zuerst die Produktanzeige, dann der Warenkorb, schließlich das Bezahlsystem.

Der Hauptunterschied liegt darin, dass die iterative Entwicklung das gesamte System wiederholt verbessert, während die inkrementelle Entwicklung das System Stück für Stück aufbaut und erweitert.


# Aufageb 2 

# Aufgabe 1: Softwareentwicklungsprozesse

## a) Ordnen Sie die folgenden Phasen dem Spiralmodell zu:
- **Risikoanalyse**
- **Planung**
- **Entwicklung und Test**
- **Bewertung und Entscheidung**

## b) Wahr oder falsch?
**Aussage:** Agile Methoden wie Scrum eignen sich besonders gut für Projekte mit klaren, unveränderlichen Anforderungen.  
**Antwort:** Falsch

**Begründung:** Agile Methoden wie Scrum sind besonders geeignet für Projekte mit sich ändernden oder unklaren Anforderungen, da sie flexibel und anpassungsfähig sind. Für Projekte mit klaren, unveränderlichen Anforderungen sind traditionelle Modelle wie das Wasserfallmodell besser geeignet.

# Aufgabe 2: Softwarearchitektur

Sie sollen eine mobile App für ein Fitnessstudio entwickeln, die Trainingsfortschritte trackt und Übungsvorschläge macht. Nennen Sie zwei UML-Diagramme, die Sie für den Entwurf für sinnvoll halten. Beschreiben Sie sie kurz und erläutern Sie, wie die Diagramme in diesem Fall zum Einsatz kommen.

## Anwendungsfalldiagramm (Use Case Diagram):
**Beschreibung:** Zeigt die Interaktionen zwischen Benutzern und dem System.  
**Einsatz:** Hilft bei der Identifizierung der Hauptfunktionen wie "Trainingsfortschritte tracken", "Übungsvorschläge anzeigen", "Benutzerprofile verwalten" etc. Dies hilft, die Anforderungen und die Benutzerinteraktionen der App klar zu definieren.

## Klassendiagramm:
**Beschreibung:** Stellt die Struktur des Systems dar, einschließlich Klassen, Attribute und Beziehungen.  
**Einsatz:** Hilft bei der Modellierung der Datenstruktur für Benutzerdaten, Trainingsfortschritte, Übungen und Vorschläge. Dies ist entscheidend für das Design der Datenbank und die Implementierung der Geschäftslogik der App.

# Aufgabe 3: Entwicklungsmethoden

## Top-Down Entwicklung:
**Beschreibung:** Beginnt mit der Gesamtstruktur des Systems und verfeinert diese schrittweise bis hin zu den einzelnen Komponenten.  
**Beispiel:** Entwicklung eines neuen Betriebssystems, bei dem zuerst die Gesamtarchitektur entworfen wird, bevor die einzelnen Module wie Speicherverwaltung, Prozessverwaltung etc. entwickelt werden.

## Bottom-Up Entwicklung:
**Beschreibung:** Beginnt mit der Entwicklung der einzelnen Komponenten oder Module, die dann schrittweise zu einem Gesamtsystem integriert werden.  
**Beispiel:** Entwicklung einer Bibliothek oder eines Frameworks, bei dem zuerst die einzelnen Funktionen und Klassen implementiert und getestet werden, bevor sie zu einer vollständigen Bibliothek zusammengeführt werden.

Der Hauptunterschied liegt darin, dass Top-Down von der Gesamtsicht zum Detail geht, während Bottom-Up vom Detail zur Gesamtsicht fortschreitet.



# Aufgaben 3 

# Aufgabe 1: Prozesse

## a) Ordnen Sie die folgenden Phasen dem V-Modell zu:
- **Anforderungsanalyse**
- **Architekturentwurf**
- **Implementierung**
- **Modultest**
- **Systemtest**

## b) Wahr oder falsch?
**Aussage:** Das Kanban-Modell in der Softwareentwicklung legt großen Wert auf feste Zeitrahmen (Sprints) für die Fertigstellung von Aufgaben.  
**Antwort:** Falsch

**Begründung:** Das Kanban-Modell legt keinen Wert auf feste Zeitrahmen (Sprints). Stattdessen konzentriert es sich auf die kontinuierliche Lieferung von Arbeit und die Optimierung des Workflows, indem es WIP (Work in Progress) begrenzt und visuell darstellt.

# Aufgabe 2: Architektur

Sie sollen eine webbasierte Anwendung für ein Bibliotheksmanagementsystem entwickeln. Das System soll die Verwaltung von Büchern, Ausleihen und Benutzern ermöglichen. Nennen Sie zwei UML-Diagramme, die Sie für den Entwurf für sinnvoll halten, beschreiben Sie sie kurz und erläutern Sie, wie die Diagramme in diesem Fall zum Einsatz kommen.

## Anwendungsfalldiagramm (Use Case Diagram):
**Beschreibung:** Zeigt die Interaktionen zwischen Benutzern und dem System.  
**Einsatz:** Hilft bei der Identifizierung der Hauptfunktionen wie "Bücher verwalten", "Ausleihen verwalten", "Benutzer verwalten" etc. Dies unterstützt die Definition der Anforderungen und die Gestaltung der Benutzerinteraktionen.

## Klassendiagramm:
**Beschreibung:** Stellt die Struktur des Systems dar, einschließlich Klassen, Attribute und Beziehungen.  
**Einsatz:** Hilft bei der Modellierung der Datenstruktur für Bücher, Ausleihen und Benutzer. Dies ist wichtig für das Design der Datenbank und die Implementierung der Geschäftslogik des Systems.

# Aufgabe 3: Verschiedenes

## Funktionale Programmierung:
**Beschreibung:** Paradigma, das Funktionen als grundlegende Bausteine verwendet und betont, dass der Programmcode deklarativ und unveränderlich ist.  
**Beispiel:** Haskell  
**Einsatz:** Besonders geeignet für Projekte, bei denen Berechnungen im Vordergrund stehen und Nebenwirkungen minimiert werden sollen, wie z.B. mathematische Anwendungen oder Datenanalyse.

## Objektorientierte Programmierung:
**Beschreibung:** Paradigma, das Objekte mit Daten und Methoden als grundlegende Bausteine verwendet und Konzepte wie Vererbung, Polymorphismus und Kapselung betont.  
**Beispiel:** Java  
**Einsatz:** Besonders geeignet für Projekte, die eine komplexe Modellierung der realen Welt erfordern, wie z.B. Geschäfts- oder Unternehmensanwendungen, bei denen verschiedene Entitäten und deren Interaktionen modelliert werden müssen.

Der Hauptunterschied liegt darin, dass die funktionale Programmierung sich auf unveränderliche Daten und Funktionen konzentriert, während die objektorientierte Programmierung Objekte und ihre Interaktionen in den Vordergrund stellt.

# Aufgaben  4 
# Aufgabe 1: Prozesse

## a) Ordnen Sie die folgenden Elemente dem Scrum-Prozess zu:
- **Sprint Planning**
- **Daily Scrum**
- **Product Backlog**
- **Sprint Review**
- **Sprint Retrospective**

## b) Wahr oder falsch?
**Aussage:** Im Extreme Programming (XP) wird auf umfangreiche Dokumentation besonders viel Wert gelegt.  
**Antwort:** Falsch

**Begründung:** Extreme Programming (XP) legt den Fokus auf ständige Kommunikation, Feedback und die laufende Verbesserung des Codes. Umfangreiche Dokumentation wird nicht als so wichtig erachtet wie funktionierender Code und direkte Kommunikation.

# Aufgabe 2: Architektur

Sie sollen eine mobile App für ein Carsharing-Unternehmen entwickeln. Die App soll es Benutzern ermöglichen, Autos zu lokalisieren, zu buchen und zu entriegeln. Nennen Sie zwei UML-Diagramme, die Sie für den Entwurf für sinnvoll halten, beschreiben Sie sie kurz und erläutern Sie, wie die Diagramme in diesem Fall zum Einsatz kommen.

## Anwendungsfalldiagramm (Use Case Diagram):
**Beschreibung:** Zeigt die Interaktionen zwischen Benutzern und dem System.  
**Einsatz:** Hilft bei der Identifizierung der Hauptfunktionen wie "Auto lokalisieren", "Auto buchen", "Auto entriegeln" etc. Dies unterstützt die Definition der Anforderungen und die Gestaltung der Benutzerinteraktionen.

## Sequenzdiagramm:
**Beschreibung:** Stellt die zeitliche Abfolge von Interaktionen zwischen verschiedenen Objekten im System dar.  
**Einsatz:** Hilft bei der Modellierung der Interaktionen und Abläufe, z.B. wie ein Benutzer ein Auto bucht und entriegelt. Dies ist wichtig, um die Logik und den Ablauf der Funktionen zu verstehen und zu optimieren.

# Aufgabe 3: Verschiedenes

## Black-Box-Testing:
**Beschreibung:** Testmethode, bei der die internen Strukturen oder das Verhalten der Anwendung nicht bekannt sind. Tester konzentrieren sich auf die Eingaben und erwarteten Ausgaben.  
**Beispiel:** Testen einer Login-Funktion, indem verschiedene Kombinationen von Benutzernamen und Passwörtern eingegeben werden, um zu überprüfen, ob der Zugang korrekt gewährt oder verweigert wird.  
**Einsatz:** Besonders geeignet für Systemtests, bei denen das Gesamtsystem als Ganzes geprüft wird, ohne die interne Logik zu kennen.

## White-Box-Testing:
**Beschreibung:** Testmethode, bei der die internen Strukturen oder das Verhalten der Anwendung bekannt sind. Tester überprüfen den Codefluss, die Logik und die internen Prozesse.  
**Beispiel:** Testen einer Sortierfunktion, indem der Quellcode überprüft wird, um sicherzustellen, dass alle möglichen Wege und Verzweigungen korrekt abgedeckt und getestet werden.  
**Einsatz:** Besonders geeignet für Unit-Tests, bei denen die Funktionalität einzelner Codeeinheiten detailliert überprüft wird.

